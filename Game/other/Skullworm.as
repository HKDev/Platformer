package  other{		import org.flixel.*;	import other.Bullet;	import flash.utils.Timer;	import flash.events.TimerEvent;	import core.State;		public class Hybrid extends FlxSprite	{		[Embed(source="../assets/hybridSprite.png")] private var ImgEnemy:Class;		public var underwater:Boolean;		public var bounced:Boolean = false;		private var _move_speed:int = 400;  		private var _max_health:int = 10;		private var _hurt_counter:Number = 0;		private var _attack_counter:Number = 0;         public function Hybrid(X:Number, Y:Number):void        {            super(X, Y);											/* frame w,h */            loadGraphic(ImgEnemy, true, true, 64, 48);			                        maxVelocity.x = 25;            maxVelocity.y = 200;						health = 2;            acceleration.y = 420;                        drag.x = 300;			// Width, Height	            width = 60;            height = 44;			// Offsets            offset.x = 4;            offset.y = 2;         	// Animations			addAnimation("normal", [0, 1, 2, 3], 10);			addAnimation("stopped", [0],0,false);			underwater = false;			checkUnderwater();        }							override public function update():void        {							// enemy object x,y location rounded			var pt:FlxPoint = new FlxPoint(Math.floor(x),Math.floor(y));			// player object x,y location rounded			var playerPt:FlxPoint = new FlxPoint(Math.floor(State.player.x),Math.floor(State.player.y));            // alive            if(!alive)            {				this.kill();                if (finished)                    exists = false;                else                    super.update();                return;            }						setBounce();            			// hurt            if (_hurt_counter > 0)            {                _hurt_counter -= FlxG.elapsed*3;            }													// standing below player			if(State.player.x == pt.x) {				play("stopped");			}				// walk left			else if(State.player.x < x) {				facing = LEFT;				velocity.x -= _move_speed * FlxG.elapsed;			}			// walk right			else            {                facing = RIGHT;                velocity.x += _move_speed * FlxG.elapsed;                            }			if (_hurt_counter > 0)            {                play("hurt");            }            else                        {                if (_attack_counter > 0)                {                    play("attack");                }                else 				{                	if (velocity.x == 0)                    {                    	play("stopped");                    }                    else                    {                 	   play("normal");                    }                }            }                 // check to see if currently under water			checkUnderwater();            super.update();                    }						override public function hurt(Damage:Number):void        {            _hurt_counter = 1;            return super.hurt(Damage);        } 		public function setBounce():void {						if(isTouching(FLOOR))			{				if (bounced)				{					bounced = false;					return;				}			}		}		public function checkUnderwater():void {			// check to see if enemy is underwater			switch(State.map.getTile(Math.floor(this.x)/16,Math.floor(this.y)/16)) { 				// id of underwater tiles				case 58: 				case 59:				case 60:				case 61:				case 62:				case 77: 				case 78:				case 79:				case 80:				case 81:					underwater = true; 						 	acceleration.y = 0;					velocity.y = 35;					break;				// other tiles				default: 					if(!underwater) return;					else { 						underwater = false;						alpha = 1;						acceleration.y = 400;					}					break;					}				}	}//class}//package