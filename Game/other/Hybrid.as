/*	Memory Inspection: 	May,20 2012 (pass)*/package  other {		import core.Assets;	import org.flixel.*;	import other.Bullet;	import core.State;	///////////////////////////////////////////////////////// [ CLASS ] ////////////////////////////////////////////////////////////////////////////	public class Hybrid extends FlxSprite	{		//booleans		public var underwater:Boolean;		public var bounced:Boolean = false;		public var angry:Boolean;		//core		private var _move_speed:int = 1500;  		private var _max_health:int = 10;		private var _hurt_counter:Number = 0;		private var _attack_counter:Number = 0;		private var _distance:Number = 0;///////////////////////////////////////////////////////// [ CONSTRUCTOR ] ////////////////////////////////////////////////////////////////////////////		 		//Hybrid        public function Hybrid(X:Number, Y:Number):void {			trace("[ + ] New Hybrid at X,Y: " + X + "," + Y );            super(X, Y);					            loadGraphic(Assets.ImgHybridEnemy, true, true, 32, 32);			//set max speed object can travel on x,y axis            maxVelocity.x = 25;            maxVelocity.y = 200;			//player health			health = 6;			//acceleration / deacceleration            acceleration.y = 420;                        drag.x = 300;			//width / height            width = 32;            height = 32;         	//sprite animations			addAnimation("normal", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 20);			addAnimation("stopped", [0],0,false);			//underwater			underwater = false;			CheckTileType(); //determine the type of tile at current position			//angry true, the hybrid chases the player			angry = false;			        }					///////////////////////////////////////////////////////// [ METHODS ] /////////////////////////////////////////////////////////////////////////////* --------------------------- */// Update		override public function update():void        {							//if there is no movement on the y axis stop. the enemy will sit and wait on the player. 			if(this.velocity.y > 0) 				play("stopped");			/* --------------------------- */// Player & Hybrid x,y rounded										//enemy object x,y location rounded			var pt:FlxPoint = new FlxPoint(Math.floor(x),Math.floor(y));			//player object x,y location rounded			var playerPt:FlxPoint = new FlxPoint(Math.floor(State.player.x),Math.floor(State.player.y));			/* --------------------------- */// Alive			            //not alive            if(!alive) {				// kill				this.kill();                if (finished)                    exists = false;                else                    super.update();                return;            }											/* --------------------------- */// Bounce								//bounce 			setBounce();			/* --------------------------- */// Hurt     			       			//hurt            if (_hurt_counter > 0){                _hurt_counter -= FlxG.elapsed*3;                play("hurt");            }		            else                        {                if (_attack_counter > 0)                {                    play("attack");                }                else 				{                	if (velocity.x == 0)                    {                    	play("stopped");                    }                    else                    {                 	   play("normal");                    }                }            }  			/* --------------------------- */// Set Angry      					// if player is left of hybrid			if(State.player.x < this.x) { 				// if player is within range we allow				if(State.player.x > this.x - 200) 					angry = true;				else					angry = false;			}			// from the right....			else if(State.player.x > this.x) { 				if(State.player.x < this.x + 200) 					angry = true;				else					angry = false;			}			// player is far enough away that hybrid is no longer angry			else 				angry = false;			/* --------------------------- *///  Is Angry   		  			if(angry) { 				if(_move_speed != 5000) _move_speed = 5000; // speed up player if not already had been sped up.  				// standing below player				if(playerPt.x == pt.x || (playerPt.x - 1) == pt.x || (playerPt.x + 1) == pt.x) {					play("stopped");				}						// walk left .. State.player.x is a more precise value than playerPt.x				else if(State.player.x < x) {					play("normal");					facing = LEFT;					if(velocity.y == 0)// move if not jumping or falling						velocity.x -= _move_speed * FlxG.elapsed;				}				// walk right				else				{					play("normal");					facing = RIGHT;					if(velocity.y == 0)// move if not jumping or falling						velocity.x += _move_speed * FlxG.elapsed;                				}			}			/* --------------------------- */// Not Angry     							else { 	// In this state of thinking the Hybrid sets destination points for itself waiting for the player's approach....				if(_move_speed != 1500) _move_speed = 1500; // reset move speed and slow hybrid down when he's not chasing you.								// if feet are planted firmly on the ground				if(this.velocity.y == 0) {										// maximum distances after calculation with player current position vs the map bounds					var maxLeft:int = State.player.x;					var maxRight:int = State.map.width - State.player.x;						// if we have traveled total distance					if(_distance <= 0) {							// make decision for left,right						var decision:Number = Math.floor(Math.random()*2+1);							//left						if(decision == 1) {							facing = LEFT;							_distance = Math.floor(Math.random()*maxLeft + 1);						}						//right						else if(decision == 2) {							facing = RIGHT; 							_distance = Math.floor(Math.random()*maxRight + 1);						}					}					else {						switch(facing) { 							case LEFT:							if(velocity.y == 0) // move if not jumping or falling								velocity.x -= _move_speed * FlxG.elapsed; 							_distance -= 1;								break;								case RIGHT:							if(velocity.y == 0) // move if not jumping or falling								velocity.x += _move_speed * FlxG.elapsed; 							_distance -= 1;								break;						}						if(playerPt.x == pt.x || (playerPt.x - 1) == pt.x || (playerPt.x + 1)) {							play("stopped");						}									else { 							play("normal");						}					} 				}			}			/* --------------------------- */// Check Tile Type                 //get the tile index number the hybrid is over and handle according to type of tile at index			CheckTileType();            super.update();            }			/* --------------------------- */// Hurt				override public function hurt(Damage:Number):void        {			flicker(0.1);            _hurt_counter = 1;            return super.hurt(Damage);        } /* --------------------------- */// Set Bounce 										public function setBounce():void {						if(isTouching(FLOOR))			{				if (bounced)				{					bounced = false;					return;				}			}		}/* --------------------------- *///  Check Tile Type @ hybrid x,y		public function CheckTileType():void {			// check to see if enemy is underwater			switch(State.map.getTile(Math.floor(this.x)/16,Math.floor(this.y)/16)) { 				// id of underwater tiles				case 58: 				case 59:				case 60:				case 61:				case 62:				case 77: 				case 78:				case 79:				case 80:				case 81:					underwater = true; 						 	acceleration.y = 0;					velocity.y = 35;					break;				// other tiles				default: 					if(!underwater) return;					else { 						underwater = false;						alpha = 1;						acceleration.y = 400;					}					break;					}				}	}//class}//package