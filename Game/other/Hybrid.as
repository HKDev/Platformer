package  other{		import org.flixel.*;	import other.Bullet;	import flash.utils.Timer;	import flash.events.TimerEvent;	import core.State;		public class Hybrid extends FlxSprite	{		[Embed(source="../assets/hybridSprite.png")] private var ImgEnemy:Class;		public var underwater:Boolean;		public var bounced:Boolean = false;		private var angry:Boolean;		private var _move_speed:int = 5000;  		private var _max_health:int = 10;		private var _hurt_counter:Number = 0;		private var _attack_counter:Number = 0;		private var _distance:Number = 0;         public function Hybrid(X:Number, Y:Number):void        {            super(X, Y);											/* frame w,h */            loadGraphic(ImgEnemy, true, true, 32, 32);			                        maxVelocity.x = 25;            maxVelocity.y = 200;						health = 2;            acceleration.y = 420;                        drag.x = 300;			// Width, Height	            width = 32;            height = 32;         	// Animations			addAnimation("normal", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 20);			addAnimation("stopped", [0],0,false);			underwater = false;			checkUnderwater();				// in angry mode the hybrid chases the player			angry = false;        }							override public function update():void        {							if(this.velocity.y > 0) play("stopped");			// enemy object x,y location rounded			var pt:FlxPoint = new FlxPoint(Math.floor(x),Math.floor(y));			// player object x,y location rounded			var playerPt:FlxPoint = new FlxPoint(Math.floor(State.player.x),Math.floor(State.player.y));            // alive            if(!alive)            {				this.kill();                if (finished)                    exists = false;                else                    super.update();                return;            }						setBounce();            			// hurt            if (_hurt_counter > 0)            {                _hurt_counter -= FlxG.elapsed*3;            }								//////////////////////////////////////////////////////////////////////////			// 						// angry from the left / tells when player is close and when to get mad			if(State.player.x < this.x) { 				if(State.player.x > this.x - 200) 					angry = true;				else					angry = false;			}			// angry from the right / same			else if(State.player.x > this.x) { 				if(State.player.x < this.x + 200) 					angry = true;				else					angry = false;			}			else 				// player is far enough away we dont have to get angry and intimidate him				angry = false;			//////////////////////////////////////////////////////////////////////////			// 	angry					if(angry) { 				// standing below player				if(playerPt.x == pt.x || (playerPt.x - 1) == pt.x || (playerPt.x + 1) == pt.x) {					play("stopped");				}						// walk left .. State.player.x is a more precise value than playerPt.x				else if(State.player.x < x) {					facing = LEFT;					if(velocity.y == 0)// move if not jumping or falling						velocity.x -= _move_speed * FlxG.elapsed;				}				// walk right				else				{					facing = RIGHT;					if(velocity.y == 0)// move if not jumping or falling						velocity.x += _move_speed * FlxG.elapsed;                				}			}			//////////////////////////////////////////////////////////////////////////			// not angry....			else { 	// In this state of thinking the Hybrid sets destination points for itself waiting for the player's approach....				// if feet are planted firmly on the ground				if(this.velocity.y == 0) {										// maximum distances after calculation with player current position vs the map bounds					var maxLeft:int = State.player.x;					var maxRight:int = State.map.width - State.player.x;						// if we have traveled total distance					if(_distance <= 0) {							// make decision for left,right						var decision:Number = Math.floor(Math.random()*2+1);							//left						if(decision == 1) {							facing = LEFT;							_distance = Math.floor(Math.random()*maxLeft + 1);						}						//right						else if(decision == 2) {							facing = RIGHT; 							_distance = Math.floor(Math.random()*maxRight + 1);						}					}					else {						switch(facing) { 							case LEFT:							if(velocity.y == 0) // move if not jumping or falling								velocity.x -= _move_speed * FlxG.elapsed; 							_distance -= 1;								break;								case RIGHT:							if(velocity.y == 0) // move if not jumping or falling								velocity.x += _move_speed * FlxG.elapsed; 							_distance -= 1;								break;						}						if(playerPt.x == pt.x || (playerPt.x - 1) == pt.x || (playerPt.x + 1)) {							play("stopped");						}								} 				}			}						//////////////////////////////////////////////////////////////////////////			if (_hurt_counter > 0)            {                play("hurt");            }            else                        {                if (_attack_counter > 0)                {                    play("attack");                }                else 				{                	if (velocity.x == 0)                    {                    	play("stopped");                    }                    else                    {                 	   play("normal");                    }                }            }                 // check to see if currently under water			checkUnderwater();            super.update();                    }						override public function hurt(Damage:Number):void        {            _hurt_counter = 1;            return super.hurt(Damage);        } 		public function setBounce():void {						if(isTouching(FLOOR))			{				if (bounced)				{					bounced = false;					return;				}			}		}		public function checkUnderwater():void {			// check to see if enemy is underwater			switch(State.map.getTile(Math.floor(this.x)/16,Math.floor(this.y)/16)) { 				// id of underwater tiles				case 58: 				case 59:				case 60:				case 61:				case 62:				case 77: 				case 78:				case 79:				case 80:				case 81:					underwater = true; 						 	acceleration.y = 0;					velocity.y = 35;					break;				// other tiles				default: 					if(!underwater) return;					else { 						underwater = false;						alpha = 1;						acceleration.y = 400;					}					break;					}				}	}//class}//package